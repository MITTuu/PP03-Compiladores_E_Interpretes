
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Jan 31 05:21:36 CST 2025
//----------------------------------------------------

package bin;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.List;
import utils.SymbolsTable.SymbolTable;
import utils.AST.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Jan 31 05:21:36 CST 2025
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\212\000\002\002\004\000\002\002\002\000\002\002" +
    "\003\000\002\066\004\000\002\066\003\000\002\066\003" +
    "\000\002\066\004\000\002\013\006\000\002\003\007\000" +
    "\002\004\003\000\002\004\003\000\002\004\003\000\002" +
    "\004\003\000\002\004\003\000\002\050\003\000\002\050" +
    "\003\000\002\010\004\000\002\011\003\000\002\011\005" +
    "\000\002\012\002\000\002\012\003\000\002\021\003\000" +
    "\002\021\004\000\002\026\003\000\002\026\003\000\002" +
    "\026\003\000\002\026\003\000\002\026\003\000\002\026" +
    "\003\000\002\026\003\000\002\026\003\000\002\026\003" +
    "\000\002\005\005\000\002\005\007\000\002\005\004\000" +
    "\002\005\006\000\002\053\005\000\002\051\006\000\002" +
    "\051\007\000\002\051\007\000\002\052\006\000\002\054" +
    "\003\000\002\054\005\000\002\020\003\000\002\020\003" +
    "\000\002\020\003\000\002\020\003\000\002\020\003\000" +
    "\002\044\007\000\002\045\007\000\002\023\003\000\002" +
    "\023\003\000\002\023\003\000\002\023\003\000\002\023" +
    "\003\000\002\023\003\000\002\007\003\000\002\015\003" +
    "\000\002\016\003\000\002\016\005\000\002\017\002\000" +
    "\002\017\003\000\002\014\006\000\002\065\004\000\002" +
    "\027\004\000\002\027\004\000\002\030\004\000\002\030" +
    "\004\000\002\022\003\000\002\025\003\000\002\025\003" +
    "\000\002\025\003\000\002\025\003\000\002\025\003\000" +
    "\002\025\003\000\002\025\005\000\002\025\004\000\002" +
    "\024\003\000\002\024\005\000\002\061\003\000\002\061" +
    "\003\000\002\061\003\000\002\061\003\000\002\061\003" +
    "\000\002\061\003\000\002\046\003\000\002\046\005\000" +
    "\002\031\003\000\002\031\003\000\002\047\003\000\002" +
    "\047\005\000\002\006\006\000\002\006\004\000\002\006" +
    "\006\000\002\006\006\000\002\032\003\000\002\032\003" +
    "\000\002\032\003\000\002\032\003\000\002\067\002\000" +
    "\002\033\012\000\002\070\002\000\002\055\007\000\002" +
    "\056\012\000\002\056\004\000\002\057\003\000\002\057" +
    "\004\000\002\057\004\000\002\071\002\000\002\034\012" +
    "\000\002\072\002\000\002\035\015\000\002\062\003\000" +
    "\002\062\003\000\002\060\003\000\002\060\005\000\002" +
    "\073\002\000\002\036\012\000\002\037\003\000\002\037" +
    "\004\000\002\074\002\000\002\040\007\000\002\040\003" +
    "\000\002\075\002\000\002\041\006\000\002\063\003\000" +
    "\002\063\003\000\002\063\003\000\002\063\003\000\002" +
    "\063\003\000\002\063\003\000\002\063\005\000\002\064" +
    "\003\000\002\064\003\000\002\064\003\000\002\042\004" +
    "\000\002\042\005\000\002\043\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\357\000\020\002\000\003\013\013\006\014\005\015" +
    "\011\016\010\017\015\001\002\000\004\002\361\001\002" +
    "\000\006\004\ufff7\005\ufff7\001\002\000\006\004\ufff8\005" +
    "\ufff8\001\002\000\006\004\056\005\347\001\002\000\006" +
    "\004\ufff4\005\ufff4\001\002\000\006\004\ufff5\005\ufff5\001" +
    "\002\000\020\002\uffff\003\345\013\006\014\005\015\011" +
    "\016\010\017\015\001\002\000\020\002\ufffc\003\ufffc\013" +
    "\ufffc\014\ufffc\015\ufffc\016\ufffc\017\ufffc\001\002\000\020" +
    "\002\ufffd\003\ufffd\013\ufffd\014\ufffd\015\ufffd\016\ufffd\017" +
    "\ufffd\001\002\000\006\004\ufff6\005\ufff6\001\002\000\004" +
    "\047\017\001\002\000\042\003\041\004\056\005\044\013" +
    "\006\014\005\015\011\016\010\017\015\052\020\054\032" +
    "\055\036\056\042\061\026\062\031\065\043\066\025\001" +
    "\002\000\004\023\335\001\002\000\004\051\334\001\002" +
    "\000\050\003\uffe6\004\uffe6\005\uffe6\013\uffe6\014\uffe6\015" +
    "\uffe6\016\uffe6\017\uffe6\050\uffe6\052\uffe6\054\uffe6\055\uffe6" +
    "\056\uffe6\057\uffe6\060\uffe6\061\uffe6\062\uffe6\065\uffe6\066" +
    "\uffe6\001\002\000\050\003\uff9f\004\uff9f\005\uff9f\013\uff9f" +
    "\014\uff9f\015\uff9f\016\uff9f\017\uff9f\050\uff9f\052\uff9f\054" +
    "\uff9f\055\uff9f\056\uff9f\057\uff9f\060\uff9f\061\uff9f\062\uff9f" +
    "\065\uff9f\066\uff9f\001\002\000\044\003\041\004\056\005" +
    "\044\013\006\014\005\015\011\016\010\017\015\050\333" +
    "\052\020\054\032\055\036\056\042\061\026\062\031\065" +
    "\043\066\025\001\002\000\004\023\327\001\002\000\004" +
    "\051\326\001\002\000\004\005\313\001\002\000\004\051" +
    "\312\001\002\000\030\004\056\005\074\006\104\007\066" +
    "\010\100\011\071\012\076\023\072\035\102\046\064\051" +
    "\307\001\002\000\004\023\300\001\002\000\004\023\270" +
    "\001\002\000\050\003\uffe5\004\uffe5\005\uffe5\013\uffe5\014" +
    "\uffe5\015\uffe5\016\uffe5\017\uffe5\050\uffe5\052\uffe5\054\uffe5" +
    "\055\uffe5\056\uffe5\057\uffe5\060\uffe5\061\uffe5\062\uffe5\065" +
    "\uffe5\066\uffe5\001\002\000\052\003\uff98\004\uff98\005\uff98" +
    "\013\uff98\014\uff98\015\uff98\016\uff98\017\uff98\050\uff98\052" +
    "\uff98\053\252\054\uff98\055\uff98\056\uff98\057\uff98\060\uff98" +
    "\061\uff98\062\uff98\065\uff98\066\uff98\001\002\000\004\023" +
    "\227\001\002\000\050\003\uffe7\004\uffe7\005\uffe7\013\uffe7" +
    "\014\uffe7\015\uffe7\016\uffe7\017\uffe7\050\uffe7\052\uffe7\054" +
    "\uffe7\055\uffe7\056\uffe7\057\uffe7\060\uffe7\061\uffe7\062\uffe7" +
    "\065\uffe7\066\uffe7\001\002\000\050\003\uffa1\004\uffa1\005" +
    "\uffa1\013\uffa1\014\uffa1\015\uffa1\016\uffa1\017\uffa1\050\uffa1" +
    "\052\uffa1\054\uffa1\055\uffa1\056\uffa1\057\uffa1\060\uffa1\061" +
    "\uffa1\062\uffa1\065\uffa1\066\uffa1\001\002\000\050\003\uffe2" +
    "\004\uffe2\005\uffe2\013\uffe2\014\uffe2\015\uffe2\016\uffe2\017" +
    "\uffe2\050\uffe2\052\uffe2\054\uffe2\055\uffe2\056\uffe2\057\uffe2" +
    "\060\uffe2\061\uffe2\062\uffe2\065\uffe2\066\uffe2\001\002\000" +
    "\004\023\167\001\002\000\004\023\163\001\002\000\014" +
    "\020\120\022\156\023\ufff3\033\116\034\117\001\002\000" +
    "\050\003\uffe4\004\uffe4\005\uffe4\013\uffe4\014\uffe4\015\uffe4" +
    "\016\uffe4\017\uffe4\050\uffe4\052\uffe4\054\uffe4\055\uffe4\056" +
    "\uffe4\057\uffe4\060\uffe4\061\uffe4\062\uffe4\065\uffe4\066\uffe4" +
    "\001\002\000\006\022\145\051\144\001\002\000\050\003" +
    "\uffe9\004\uffe9\005\uffe9\013\uffe9\014\uffe9\015\uffe9\016\uffe9" +
    "\017\uffe9\050\uffe9\052\uffe9\054\uffe9\055\uffe9\056\uffe9\057" +
    "\uffe9\060\uffe9\061\uffe9\062\uffe9\065\uffe9\066\uffe9\001\002" +
    "\000\004\022\060\001\002\000\050\003\uffea\004\uffea\005" +
    "\uffea\013\uffea\014\uffea\015\uffea\016\uffea\017\uffea\050\uffea" +
    "\052\uffea\054\uffea\055\uffea\056\uffea\057\uffea\060\uffea\061" +
    "\uffea\062\uffea\065\uffea\066\uffea\001\002\000\050\003\uffa2" +
    "\004\uffa2\005\uffa2\013\uffa2\014\uffa2\015\uffa2\016\uffa2\017" +
    "\uffa2\050\uffa2\052\uffa2\054\uffa2\055\uffa2\056\uffa2\057\uffa2" +
    "\060\uffa2\061\uffa2\062\uffa2\065\uffa2\066\uffa2\001\002\000" +
    "\050\003\uffe3\004\uffe3\005\uffe3\013\uffe3\014\uffe3\015\uffe3" +
    "\016\uffe3\017\uffe3\050\uffe3\052\uffe3\054\uffe3\055\uffe3\056" +
    "\uffe3\057\uffe3\060\uffe3\061\uffe3\062\uffe3\065\uffe3\066\uffe3" +
    "\001\002\000\050\003\uffe8\004\uffe8\005\uffe8\013\uffe8\014" +
    "\uffe8\015\uffe8\016\uffe8\017\uffe8\050\uffe8\052\uffe8\054\uffe8" +
    "\055\uffe8\056\uffe8\057\uffe8\060\uffe8\061\uffe8\062\uffe8\065" +
    "\uffe8\066\uffe8\001\002\000\050\003\uffec\004\uffec\005\uffec" +
    "\013\uffec\014\uffec\015\uffec\016\uffec\017\uffec\050\uffec\052" +
    "\uffec\054\uffec\055\uffec\056\uffec\057\uffec\060\uffec\061\uffec" +
    "\062\uffec\065\uffec\066\uffec\001\002\000\004\023\ufff2\001" +
    "\002\000\050\003\uffa0\004\uffa0\005\uffa0\013\uffa0\014\uffa0" +
    "\015\uffa0\016\uffa0\017\uffa0\050\uffa0\052\uffa0\054\uffa0\055" +
    "\uffa0\056\uffa0\057\uffa0\060\uffa0\061\uffa0\062\uffa0\065\uffa0" +
    "\066\uffa0\001\002\000\026\004\056\005\074\006\104\007" +
    "\066\010\100\011\071\012\076\023\072\035\102\046\064" +
    "\001\002\000\046\021\uffb7\024\uffb7\025\uffb7\026\uffb7\027" +
    "\uffb7\030\uffb7\031\uffb7\032\uffb7\036\uffb7\037\uffb7\040\uffb7" +
    "\041\uffb7\042\uffb7\043\uffb7\044\uffb7\045\uffb7\051\uffb7\064" +
    "\uffb7\001\002\000\044\021\uffac\024\uffac\025\136\026\141" +
    "\027\135\030\137\031\140\032\134\036\uffac\037\uffac\040" +
    "\uffac\041\uffac\042\uffac\043\uffac\044\uffac\045\uffac\051\uffac" +
    "\001\002\000\014\021\uffbd\024\uffbd\044\132\045\131\051" +
    "\uffbd\001\002\000\026\004\056\005\074\006\104\007\066" +
    "\010\100\011\071\012\076\023\072\035\102\046\064\001" +
    "\002\000\006\006\126\007\125\001\002\000\050\021\uffd5" +
    "\024\uffd5\025\uffd5\026\uffd5\027\uffd5\030\uffd5\031\uffd5\032" +
    "\uffd5\036\uffd5\037\uffd5\040\uffd5\041\uffd5\042\uffd5\043\uffd5" +
    "\044\uffd5\045\uffd5\050\uffd5\051\uffd5\064\uffd5\001\002\000" +
    "\046\021\uffb8\024\uffb8\025\uffb8\026\uffb8\027\uffb8\030\uffb8" +
    "\031\uffb8\032\uffb8\036\uffb8\037\uffb8\040\uffb8\041\uffb8\042" +
    "\uffb8\043\uffb8\044\uffb8\045\uffb8\051\uffb8\064\uffb8\001\002" +
    "\000\044\021\uffb4\024\uffb4\025\uffb4\026\uffb4\027\uffb4\030" +
    "\uffb4\031\uffb4\032\uffb4\036\uffb4\037\uffb4\040\uffb4\041\uffb4" +
    "\042\uffb4\043\uffb4\044\uffb4\045\uffb4\051\uffb4\001\002\000" +
    "\050\021\uffd3\024\uffd3\025\uffd3\026\uffd3\027\uffd3\030\uffd3" +
    "\031\uffd3\032\uffd3\036\uffd3\037\uffd3\040\uffd3\041\uffd3\042" +
    "\uffd3\043\uffd3\044\uffd3\045\uffd3\050\uffd3\051\uffd3\064\uffd3" +
    "\001\002\000\026\004\056\005\074\006\104\007\066\010" +
    "\100\011\071\012\076\023\072\035\102\046\064\001\002" +
    "\000\046\021\uffba\024\uffba\025\uffba\026\uffba\027\uffba\030" +
    "\uffba\031\uffba\032\uffba\036\uffba\037\uffba\040\uffba\041\uffba" +
    "\042\uffba\043\uffba\044\uffba\045\uffba\051\uffba\064\uffba\001" +
    "\002\000\056\020\120\021\uffbc\023\ufff3\024\uffbc\025\uffbc" +
    "\026\uffbc\027\uffbc\030\uffbc\031\uffbc\032\uffbc\033\116\034" +
    "\117\036\uffbc\037\uffbc\040\uffbc\041\uffbc\042\uffbc\043\uffbc" +
    "\044\uffbc\045\uffbc\051\uffbc\064\uffbc\001\002\000\046\021" +
    "\uffb9\024\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9" +
    "\032\uffb9\036\uffb9\037\uffb9\040\uffb9\041\uffb9\042\uffb9\043" +
    "\uffb9\044\uffb9\045\uffb9\051\uffb9\064\uffb9\001\002\000\050" +
    "\021\uffd2\024\uffd2\025\uffd2\026\uffd2\027\uffd2\030\uffd2\031" +
    "\uffd2\032\uffd2\036\uffd2\037\uffd2\040\uffd2\041\uffd2\042\uffd2" +
    "\043\uffd2\044\uffd2\045\uffd2\050\uffd2\051\uffd2\064\uffd2\001" +
    "\002\000\030\021\uffa8\024\uffa8\036\114\037\107\040\110" +
    "\041\111\042\106\043\112\044\uffa8\045\uffa8\051\uffa8\001" +
    "\002\000\050\021\uffd4\024\uffd4\025\uffd4\026\uffd4\027\uffd4" +
    "\030\uffd4\031\uffd4\032\uffd4\036\uffd4\037\uffd4\040\uffd4\041" +
    "\uffd4\042\uffd4\043\uffd4\044\uffd4\045\uffd4\050\uffd4\051\uffd4" +
    "\064\uffd4\001\002\000\004\051\105\001\002\000\006\006" +
    "\uffc9\007\uffc9\001\002\000\046\021\uffbb\024\uffbb\025\uffbb" +
    "\026\uffbb\027\uffbb\030\uffbb\031\uffbb\032\uffbb\036\uffbb\037" +
    "\uffbb\040\uffbb\041\uffbb\042\uffbb\043\uffbb\044\uffbb\045\uffbb" +
    "\051\uffbb\064\uffbb\001\002\000\050\021\uffd6\024\uffd6\025" +
    "\uffd6\026\uffd6\027\uffd6\030\uffd6\031\uffd6\032\uffd6\036\uffd6" +
    "\037\uffd6\040\uffd6\041\uffd6\042\uffd6\043\uffd6\044\uffd6\045" +
    "\uffd6\050\uffd6\051\uffd6\064\uffd6\001\002\000\070\003\uffa3" +
    "\004\uffa3\005\uffa3\006\uffa3\007\uffa3\010\uffa3\011\uffa3\012" +
    "\uffa3\013\uffa3\014\uffa3\015\uffa3\016\uffa3\017\uffa3\023\uffa3" +
    "\035\uffa3\046\uffa3\050\uffa3\052\uffa3\054\uffa3\055\uffa3\056" +
    "\uffa3\057\uffa3\060\uffa3\061\uffa3\062\uffa3\065\uffa3\066\uffa3" +
    "\001\002\000\026\004\uffae\005\uffae\006\uffae\007\uffae\010" +
    "\uffae\011\uffae\012\uffae\023\uffae\035\uffae\046\uffae\001\002" +
    "\000\026\004\uffb1\005\uffb1\006\uffb1\007\uffb1\010\uffb1\011" +
    "\uffb1\012\uffb1\023\uffb1\035\uffb1\046\uffb1\001\002\000\026" +
    "\004\uffb0\005\uffb0\006\uffb0\007\uffb0\010\uffb0\011\uffb0\012" +
    "\uffb0\023\uffb0\035\uffb0\046\uffb0\001\002\000\026\004\uffaf" +
    "\005\uffaf\006\uffaf\007\uffaf\010\uffaf\011\uffaf\012\uffaf\023" +
    "\uffaf\035\uffaf\046\uffaf\001\002\000\026\004\uffad\005\uffad" +
    "\006\uffad\007\uffad\010\uffad\011\uffad\012\uffad\023\uffad\035" +
    "\uffad\046\uffad\001\002\000\026\004\056\005\074\006\104" +
    "\007\066\010\100\011\071\012\076\023\072\035\102\046" +
    "\064\001\002\000\026\004\uffb2\005\uffb2\006\uffb2\007\uffb2" +
    "\010\uffb2\011\uffb2\012\uffb2\023\uffb2\035\uffb2\046\uffb2\001" +
    "\002\000\030\021\uffab\024\uffab\036\114\037\107\040\110" +
    "\041\111\042\106\043\112\044\uffab\045\uffab\051\uffab\001" +
    "\002\000\046\021\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf" +
    "\030\uffbf\031\uffbf\032\uffbf\036\uffbf\037\uffbf\040\uffbf\041" +
    "\uffbf\042\uffbf\043\uffbf\044\uffbf\045\uffbf\051\uffbf\064\uffbf" +
    "\001\002\000\046\021\uffbe\024\uffbe\025\uffbe\026\uffbe\027" +
    "\uffbe\030\uffbe\031\uffbe\032\uffbe\036\uffbe\037\uffbe\040\uffbe" +
    "\041\uffbe\042\uffbe\043\uffbe\044\uffbe\045\uffbe\051\uffbe\064" +
    "\uffbe\001\002\000\026\004\056\005\074\006\104\007\066" +
    "\010\100\011\071\012\076\023\072\035\102\046\064\001" +
    "\002\000\004\021\122\001\002\000\050\021\uffd9\022\uffd9" +
    "\024\uffd9\025\uffd9\026\uffd9\027\uffd9\030\uffd9\031\uffd9\032" +
    "\uffd9\036\uffd9\037\uffd9\040\uffd9\041\uffd9\042\uffd9\043\uffd9" +
    "\044\uffd9\045\uffd9\051\uffd9\064\uffd9\001\002\000\004\024" +
    "\124\001\002\000\046\021\uffb6\024\uffb6\025\uffb6\026\uffb6" +
    "\027\uffb6\030\uffb6\031\uffb6\032\uffb6\036\uffb6\037\uffb6\040" +
    "\uffb6\041\uffb6\042\uffb6\043\uffb6\044\uffb6\045\uffb6\051\uffb6" +
    "\064\uffb6\001\002\000\046\021\uffc0\024\uffc0\025\uffc0\026" +
    "\uffc0\027\uffc0\030\uffc0\031\uffc0\032\uffc0\036\uffc0\037\uffc0" +
    "\040\uffc0\041\uffc0\042\uffc0\043\uffc0\044\uffc0\045\uffc0\051" +
    "\uffc0\064\uffc0\001\002\000\046\021\uffc1\024\uffc1\025\uffc1" +
    "\026\uffc1\027\uffc1\030\uffc1\031\uffc1\032\uffc1\036\uffc1\037" +
    "\uffc1\040\uffc1\041\uffc1\042\uffc1\043\uffc1\044\uffc1\045\uffc1" +
    "\051\uffc1\064\uffc1\001\002\000\046\021\uffb5\024\uffb5\025" +
    "\uffb5\026\uffb5\027\uffb5\030\uffb5\031\uffb5\032\uffb5\036\uffb5" +
    "\037\uffb5\040\uffb5\041\uffb5\042\uffb5\043\uffb5\044\uffb5\045" +
    "\uffb5\051\uffb5\064\uffb5\001\002\000\026\004\056\005\074" +
    "\006\104\007\066\010\100\011\071\012\076\023\072\035" +
    "\102\046\064\001\002\000\026\004\uffa9\005\uffa9\006\uffa9" +
    "\007\uffa9\010\uffa9\011\uffa9\012\uffa9\023\uffa9\035\uffa9\046" +
    "\uffa9\001\002\000\026\004\uffaa\005\uffaa\006\uffaa\007\uffaa" +
    "\010\uffaa\011\uffaa\012\uffaa\023\uffaa\035\uffaa\046\uffaa\001" +
    "\002\000\014\021\uffa7\024\uffa7\044\132\045\131\051\uffa7" +
    "\001\002\000\026\004\uffca\005\uffca\006\uffca\007\uffca\010" +
    "\uffca\011\uffca\012\uffca\023\uffca\035\uffca\046\uffca\001\002" +
    "\000\026\004\uffcc\005\uffcc\006\uffcc\007\uffcc\010\uffcc\011" +
    "\uffcc\012\uffcc\023\uffcc\035\uffcc\046\uffcc\001\002\000\026" +
    "\004\uffcf\005\uffcf\006\uffcf\007\uffcf\010\uffcf\011\uffcf\012" +
    "\uffcf\023\uffcf\035\uffcf\046\uffcf\001\002\000\026\004\uffcd" +
    "\005\uffcd\006\uffcd\007\uffcd\010\uffcd\011\uffcd\012\uffcd\023" +
    "\uffcd\035\uffcd\046\uffcd\001\002\000\026\004\uffcb\005\uffcb" +
    "\006\uffcb\007\uffcb\010\uffcb\011\uffcb\012\uffcb\023\uffcb\035" +
    "\uffcb\046\uffcb\001\002\000\026\004\uffce\005\uffce\006\uffce" +
    "\007\uffce\010\uffce\011\uffce\012\uffce\023\uffce\035\uffce\046" +
    "\uffce\001\002\000\026\004\056\005\074\006\104\007\066" +
    "\010\100\011\071\012\076\023\072\035\102\046\064\001" +
    "\002\000\044\021\uffb3\024\uffb3\025\136\026\141\027\135" +
    "\030\137\031\140\032\134\036\uffb3\037\uffb3\040\uffb3\041" +
    "\uffb3\042\uffb3\043\uffb3\044\uffb3\045\uffb3\051\uffb3\001\002" +
    "\000\070\003\uffdf\004\uffdf\005\uffdf\006\uffdf\007\uffdf\010" +
    "\uffdf\011\uffdf\012\uffdf\013\uffdf\014\uffdf\015\uffdf\016\uffdf" +
    "\017\uffdf\023\uffdf\035\uffdf\046\uffdf\050\uffdf\052\uffdf\054" +
    "\uffdf\055\uffdf\056\uffdf\057\uffdf\060\uffdf\061\uffdf\062\uffdf" +
    "\065\uffdf\066\uffdf\001\002\000\004\047\146\001\002\000" +
    "\014\006\104\007\066\010\100\011\071\012\076\001\002" +
    "\000\004\051\150\001\002\000\070\003\uffde\004\uffde\005" +
    "\uffde\006\uffde\007\uffde\010\uffde\011\uffde\012\uffde\013\uffde" +
    "\014\uffde\015\uffde\016\uffde\017\uffde\023\uffde\035\uffde\046" +
    "\uffde\050\uffde\052\uffde\054\uffde\055\uffde\056\uffde\057\uffde" +
    "\060\uffde\061\uffde\062\uffde\065\uffde\066\uffde\001\002\000" +
    "\006\050\uffd8\064\uffd8\001\002\000\006\050\153\064\154" +
    "\001\002\000\004\051\uffdd\001\002\000\014\006\104\007" +
    "\066\010\100\011\071\012\076\001\002\000\006\050\uffd7" +
    "\064\uffd7\001\002\000\030\004\056\005\074\006\104\007" +
    "\066\010\100\011\071\012\076\023\072\035\102\046\064" +
    "\047\146\001\002\000\004\051\162\001\002\000\004\051" +
    "\161\001\002\000\070\003\uffa6\004\uffa6\005\uffa6\006\uffa6" +
    "\007\uffa6\010\uffa6\011\uffa6\012\uffa6\013\uffa6\014\uffa6\015" +
    "\uffa6\016\uffa6\017\uffa6\023\uffa6\035\uffa6\046\uffa6\050\uffa6" +
    "\052\uffa6\054\uffa6\055\uffa6\056\uffa6\057\uffa6\060\uffa6\061" +
    "\uffa6\062\uffa6\065\uffa6\066\uffa6\001\002\000\070\003\uffa4" +
    "\004\uffa4\005\uffa4\006\uffa4\007\uffa4\010\uffa4\011\uffa4\012" +
    "\uffa4\013\uffa4\014\uffa4\015\uffa4\016\uffa4\017\uffa4\023\uffa4" +
    "\035\uffa4\046\uffa4\050\uffa4\052\uffa4\054\uffa4\055\uffa4\056" +
    "\uffa4\057\uffa4\060\uffa4\061\uffa4\062\uffa4\065\uffa4\066\uffa4" +
    "\001\002\000\026\004\056\005\074\006\104\007\066\010" +
    "\100\011\071\012\076\023\072\035\102\046\064\001\002" +
    "\000\004\024\165\001\002\000\004\051\166\001\002\000" +
    "\050\003\uffd1\004\uffd1\005\uffd1\013\uffd1\014\uffd1\015\uffd1" +
    "\016\uffd1\017\uffd1\050\uffd1\052\uffd1\054\uffd1\055\uffd1\056" +
    "\uffd1\057\uffd1\060\uffd1\061\uffd1\062\uffd1\065\uffd1\066\uffd1" +
    "\001\002\000\014\004\056\005\173\006\174\011\171\023" +
    "\175\001\002\000\004\024\202\001\002\000\004\024\uff82" +
    "\001\002\000\004\024\uff7f\001\002\000\014\020\120\023" +
    "\ufff3\024\uff84\033\116\034\117\001\002\000\004\024\uff83" +
    "\001\002\000\026\004\056\005\074\006\104\007\066\010" +
    "\100\011\071\012\076\023\072\035\102\046\064\001\002" +
    "\000\004\024\uff81\001\002\000\004\024\uff80\001\002\000" +
    "\004\024\201\001\002\000\004\024\uff7e\001\002\000\004" +
    "\047\203\001\002\000\006\057\uff8d\060\uff8d\001\002\000" +
    "\006\057\205\060\206\001\002\000\010\005\223\006\222" +
    "\011\220\001\002\000\004\063\214\001\002\000\010\050" +
    "\uff87\057\uff87\060\uff87\001\002\000\010\050\212\057\205" +
    "\060\206\001\002\000\010\050\uff8b\057\uff8b\060\uff8b\001" +
    "\002\000\050\003\uff8c\004\uff8c\005\uff8c\013\uff8c\014\uff8c" +
    "\015\uff8c\016\uff8c\017\uff8c\050\uff8c\052\uff8c\054\uff8c\055" +
    "\uff8c\056\uff8c\057\uff8c\060\uff8c\061\uff8c\062\uff8c\065\uff8c" +
    "\066\uff8c\001\002\000\010\050\uff8a\057\uff8a\060\uff8a\001" +
    "\002\000\042\003\uff86\004\uff86\005\uff86\013\uff86\014\uff86" +
    "\015\uff86\016\uff86\017\uff86\052\uff86\054\uff86\055\uff86\056" +
    "\uff86\061\uff86\062\uff86\065\uff86\066\uff86\001\002\000\042" +
    "\003\041\004\056\005\044\013\006\014\005\015\011\016" +
    "\010\017\015\052\020\054\032\055\036\056\042\061\026" +
    "\062\031\065\043\066\025\001\002\000\050\003\041\004" +
    "\056\005\044\013\006\014\005\015\011\016\010\017\015" +
    "\050\uff85\052\020\054\032\055\036\056\042\057\uff85\060" +
    "\uff85\061\026\062\031\065\043\066\025\001\002\000\050" +
    "\003\uffeb\004\uffeb\005\uffeb\013\uffeb\014\uffeb\015\uffeb\016" +
    "\uffeb\017\uffeb\050\uffeb\052\uffeb\054\uffeb\055\uffeb\056\uffeb" +
    "\057\uffeb\060\uffeb\061\uffeb\062\uffeb\065\uffeb\066\uffeb\001" +
    "\002\000\004\063\uff7b\001\002\000\004\063\224\001\002" +
    "\000\004\063\uff7c\001\002\000\004\063\uff7d\001\002\000" +
    "\042\003\uff89\004\uff89\005\uff89\013\uff89\014\uff89\015\uff89" +
    "\016\uff89\017\uff89\052\uff89\054\uff89\055\uff89\056\uff89\061" +
    "\uff89\062\uff89\065\uff89\066\uff89\001\002\000\042\003\041" +
    "\004\056\005\044\013\006\014\005\015\011\016\010\017" +
    "\015\052\020\054\032\055\036\056\042\061\026\062\031" +
    "\065\043\066\025\001\002\000\050\003\041\004\056\005" +
    "\044\013\006\014\005\015\011\016\010\017\015\050\uff88" +
    "\052\020\054\032\055\036\056\042\057\uff88\060\uff88\061" +
    "\026\062\031\065\043\066\025\001\002\000\016\005\231" +
    "\013\006\014\005\015\011\016\010\017\015\001\002\000" +
    "\026\004\uff91\005\uff91\006\uff91\007\uff91\010\uff91\011\uff91" +
    "\012\uff91\023\uff91\035\uff91\046\uff91\001\002\000\012\020" +
    "\120\022\156\033\116\034\117\001\002\000\026\004\056" +
    "\005\074\006\104\007\066\010\100\011\071\012\076\023" +
    "\072\035\102\046\064\001\002\000\026\004\uff90\005\uff90" +
    "\006\uff90\007\uff90\010\uff90\011\uff90\012\uff90\023\uff90\035" +
    "\uff90\046\uff90\001\002\000\010\044\132\045\131\051\235" +
    "\001\002\000\004\005\240\001\002\000\004\024\243\001" +
    "\002\000\004\024\uff8f\001\002\000\010\022\241\033\116" +
    "\034\117\001\002\000\026\004\056\005\074\006\104\007" +
    "\066\010\100\011\071\012\076\023\072\035\102\046\064" +
    "\001\002\000\004\024\uff8e\001\002\000\004\047\244\001" +
    "\002\000\042\003\uff93\004\uff93\005\uff93\013\uff93\014\uff93" +
    "\015\uff93\016\uff93\017\uff93\052\uff93\054\uff93\055\uff93\056" +
    "\uff93\061\uff93\062\uff93\065\uff93\066\uff93\001\002\000\042" +
    "\003\041\004\056\005\044\013\006\014\005\015\011\016" +
    "\010\017\015\052\020\054\032\055\036\056\042\061\026" +
    "\062\031\065\043\066\025\001\002\000\044\003\041\004" +
    "\056\005\044\013\006\014\005\015\011\016\010\017\015" +
    "\050\247\052\020\054\032\055\036\056\042\061\026\062" +
    "\031\065\043\066\025\001\002\000\050\003\uff92\004\uff92" +
    "\005\uff92\013\uff92\014\uff92\015\uff92\016\uff92\017\uff92\050" +
    "\uff92\052\uff92\054\uff92\055\uff92\056\uff92\057\uff92\060\uff92" +
    "\061\uff92\062\uff92\065\uff92\066\uff92\001\002\000\052\003" +
    "\uff96\004\uff96\005\uff96\013\uff96\014\uff96\015\uff96\016\uff96" +
    "\017\uff96\050\uff96\052\uff96\053\267\054\uff96\055\uff96\056" +
    "\uff96\057\uff96\060\uff96\061\uff96\062\uff96\065\uff96\066\uff96" +
    "\001\002\000\050\003\uff97\004\uff97\005\uff97\013\uff97\014" +
    "\uff97\015\uff97\016\uff97\017\uff97\050\uff97\052\uff97\054\uff97" +
    "\055\uff97\056\uff97\057\uff97\060\uff97\061\uff97\062\uff97\065" +
    "\uff97\066\uff97\001\002\000\006\047\253\052\254\001\002" +
    "\000\042\003\uff9c\004\uff9c\005\uff9c\013\uff9c\014\uff9c\015" +
    "\uff9c\016\uff9c\017\uff9c\052\uff9c\054\uff9c\055\uff9c\056\uff9c" +
    "\061\uff9c\062\uff9c\065\uff9c\066\uff9c\001\002\000\004\023" +
    "\255\001\002\000\026\004\056\005\074\006\104\007\066" +
    "\010\100\011\071\012\076\023\072\035\102\046\064\001" +
    "\002\000\010\024\257\044\132\045\131\001\002\000\004" +
    "\047\260\001\002\000\042\003\041\004\056\005\044\013" +
    "\006\014\005\015\011\016\010\017\015\052\020\054\032" +
    "\055\036\056\042\061\026\062\031\065\043\066\025\001" +
    "\002\000\044\003\041\004\056\005\044\013\006\014\005" +
    "\015\011\016\010\017\015\050\262\052\020\054\032\055" +
    "\036\056\042\061\026\062\031\065\043\066\025\001\002" +
    "\000\052\003\uff9a\004\uff9a\005\uff9a\013\uff9a\014\uff9a\015" +
    "\uff9a\016\uff9a\017\uff9a\050\uff9a\052\uff9a\053\uff9a\054\uff9a" +
    "\055\uff9a\056\uff9a\057\uff9a\060\uff9a\061\uff9a\062\uff9a\065" +
    "\uff9a\066\uff9a\001\002\000\042\003\041\004\056\005\044" +
    "\013\006\014\005\015\011\016\010\017\015\052\020\054" +
    "\032\055\036\056\042\061\026\062\031\065\043\066\025" +
    "\001\002\000\044\003\041\004\056\005\044\013\006\014" +
    "\005\015\011\016\010\017\015\050\265\052\020\054\032" +
    "\055\036\056\042\061\026\062\031\065\043\066\025\001" +
    "\002\000\052\003\uff9b\004\uff9b\005\uff9b\013\uff9b\014\uff9b" +
    "\015\uff9b\016\uff9b\017\uff9b\050\uff9b\052\uff9b\053\uff9b\054" +
    "\uff9b\055\uff9b\056\uff9b\057\uff9b\060\uff9b\061\uff9b\062\uff9b" +
    "\065\uff9b\066\uff9b\001\002\000\052\003\uff99\004\uff99\005" +
    "\uff99\013\uff99\014\uff99\015\uff99\016\uff99\017\uff99\050\uff99" +
    "\052\uff99\053\uff99\054\uff99\055\uff99\056\uff99\057\uff99\060" +
    "\uff99\061\uff99\062\uff99\065\uff99\066\uff99\001\002\000\004" +
    "\047\253\001\002\000\030\004\056\005\074\006\104\007" +
    "\066\010\100\011\071\012\076\023\072\024\uffc5\035\102" +
    "\046\064\001\002\000\006\024\uffc7\064\uffc7\001\002\000" +
    "\006\024\uffc4\064\276\001\002\000\006\024\uffc8\064\uffc8" +
    "\001\002\000\004\024\275\001\002\000\046\021\uffc3\024" +
    "\uffc3\025\uffc3\026\uffc3\027\uffc3\030\uffc3\031\uffc3\032\uffc3" +
    "\036\uffc3\037\uffc3\040\uffc3\041\uffc3\042\uffc3\043\uffc3\044" +
    "\uffc3\045\uffc3\051\uffc3\064\uffc3\001\002\000\026\004\056" +
    "\005\074\006\104\007\066\010\100\011\071\012\076\023" +
    "\072\035\102\046\064\001\002\000\006\024\uffc6\064\uffc6" +
    "\001\002\000\026\004\056\005\074\006\104\007\066\010" +
    "\100\011\071\012\076\023\072\035\102\046\064\001\002" +
    "\000\010\024\302\044\132\045\131\001\002\000\004\047" +
    "\303\001\002\000\042\003\uff95\004\uff95\005\uff95\013\uff95" +
    "\014\uff95\015\uff95\016\uff95\017\uff95\052\uff95\054\uff95\055" +
    "\uff95\056\uff95\061\uff95\062\uff95\065\uff95\066\uff95\001\002" +
    "\000\042\003\041\004\056\005\044\013\006\014\005\015" +
    "\011\016\010\017\015\052\020\054\032\055\036\056\042" +
    "\061\026\062\031\065\043\066\025\001\002\000\044\003" +
    "\041\004\056\005\044\013\006\014\005\015\011\016\010" +
    "\017\015\050\306\052\020\054\032\055\036\056\042\061" +
    "\026\062\031\065\043\066\025\001\002\000\050\003\uff94" +
    "\004\uff94\005\uff94\013\uff94\014\uff94\015\uff94\016\uff94\017" +
    "\uff94\050\uff94\052\uff94\054\uff94\055\uff94\056\uff94\057\uff94" +
    "\060\uff94\061\uff94\062\uff94\065\uff94\066\uff94\001\002\000" +
    "\050\003\uff7a\004\uff7a\005\uff7a\013\uff7a\014\uff7a\015\uff7a" +
    "\016\uff7a\017\uff7a\050\uff7a\052\uff7a\054\uff7a\055\uff7a\056" +
    "\uff7a\057\uff7a\060\uff7a\061\uff7a\062\uff7a\065\uff7a\066\uff7a" +
    "\001\002\000\004\051\311\001\002\000\050\003\uff79\004" +
    "\uff79\005\uff79\013\uff79\014\uff79\015\uff79\016\uff79\017\uff79" +
    "\050\uff79\052\uff79\054\uff79\055\uff79\056\uff79\057\uff79\060" +
    "\uff79\061\uff79\062\uff79\065\uff79\066\uff79\001\002\000\070" +
    "\003\uffa5\004\uffa5\005\uffa5\006\uffa5\007\uffa5\010\uffa5\011" +
    "\uffa5\012\uffa5\013\uffa5\014\uffa5\015\uffa5\016\uffa5\017\uffa5" +
    "\023\uffa5\035\uffa5\046\uffa5\050\uffa5\052\uffa5\054\uffa5\055" +
    "\uffa5\056\uffa5\057\uffa5\060\uffa5\061\uffa5\062\uffa5\065\uffa5" +
    "\066\uffa5\001\002\000\010\020\316\022\315\051\314\001" +
    "\002\000\070\003\uffe1\004\uffe1\005\uffe1\006\uffe1\007\uffe1" +
    "\010\uffe1\011\uffe1\012\uffe1\013\uffe1\014\uffe1\015\uffe1\016" +
    "\uffe1\017\uffe1\023\uffe1\035\uffe1\046\uffe1\050\uffe1\052\uffe1" +
    "\054\uffe1\055\uffe1\056\uffe1\057\uffe1\060\uffe1\061\uffe1\062" +
    "\uffe1\065\uffe1\066\uffe1\001\002\000\026\004\056\005\074" +
    "\006\104\007\066\010\100\011\071\012\076\023\072\035" +
    "\102\046\064\001\002\000\010\005\321\006\320\021\317" +
    "\001\002\000\006\022\uffdc\051\uffdc\001\002\000\004\021" +
    "\323\001\002\000\004\021\322\001\002\000\006\022\uffda" +
    "\051\uffda\001\002\000\006\022\uffdb\051\uffdb\001\002\000" +
    "\004\051\325\001\002\000\070\003\uffe0\004\uffe0\005\uffe0" +
    "\006\uffe0\007\uffe0\010\uffe0\011\uffe0\012\uffe0\013\uffe0\014" +
    "\uffe0\015\uffe0\016\uffe0\017\uffe0\023\uffe0\035\uffe0\046\uffe0" +
    "\050\uffe0\052\uffe0\054\uffe0\055\uffe0\056\uffe0\057\uffe0\060" +
    "\uffe0\061\uffe0\062\uffe0\065\uffe0\066\uffe0\001\002\000\050" +
    "\003\uff78\004\uff78\005\uff78\013\uff78\014\uff78\015\uff78\016" +
    "\uff78\017\uff78\050\uff78\052\uff78\054\uff78\055\uff78\056\uff78" +
    "\057\uff78\060\uff78\061\uff78\062\uff78\065\uff78\066\uff78\001" +
    "\002\000\026\004\056\005\074\006\104\007\066\010\100" +
    "\011\071\012\076\023\072\035\102\046\064\001\002\000" +
    "\004\024\331\001\002\000\004\051\332\001\002\000\050" +
    "\003\uffd0\004\uffd0\005\uffd0\013\uffd0\014\uffd0\015\uffd0\016" +
    "\uffd0\017\uffd0\050\uffd0\052\uffd0\054\uffd0\055\uffd0\056\uffd0" +
    "\057\uffd0\060\uffd0\061\uffd0\062\uffd0\065\uffd0\066\uffd0\001" +
    "\002\000\020\002\ufffa\003\ufffa\013\ufffa\014\ufffa\015\ufffa" +
    "\016\ufffa\017\ufffa\001\002\000\050\003\uffc2\004\uffc2\005" +
    "\uffc2\013\uffc2\014\uffc2\015\uffc2\016\uffc2\017\uffc2\050\uffc2" +
    "\052\uffc2\054\uffc2\055\uffc2\056\uffc2\057\uffc2\060\uffc2\061" +
    "\uffc2\062\uffc2\065\uffc2\066\uffc2\001\002\000\026\004\056" +
    "\005\074\006\104\007\066\010\100\011\071\012\076\023" +
    "\072\035\102\046\064\001\002\000\010\024\337\044\132" +
    "\045\131\001\002\000\004\047\340\001\002\000\042\003" +
    "\uff9e\004\uff9e\005\uff9e\013\uff9e\014\uff9e\015\uff9e\016\uff9e" +
    "\017\uff9e\052\uff9e\054\uff9e\055\uff9e\056\uff9e\061\uff9e\062" +
    "\uff9e\065\uff9e\066\uff9e\001\002\000\042\003\041\004\056" +
    "\005\044\013\006\014\005\015\011\016\010\017\015\052" +
    "\020\054\032\055\036\056\042\061\026\062\031\065\043" +
    "\066\025\001\002\000\044\003\041\004\056\005\044\013" +
    "\006\014\005\015\011\016\010\017\015\050\343\052\020" +
    "\054\032\055\036\056\042\061\026\062\031\065\043\066" +
    "\025\001\002\000\052\003\uff9d\004\uff9d\005\uff9d\013\uff9d" +
    "\014\uff9d\015\uff9d\016\uff9d\017\uff9d\050\uff9d\052\uff9d\053" +
    "\uff9d\054\uff9d\055\uff9d\056\uff9d\057\uff9d\060\uff9d\061\uff9d" +
    "\062\uff9d\065\uff9d\066\uff9d\001\002\000\020\002\ufffe\003" +
    "\ufffe\013\ufffe\014\ufffe\015\ufffe\016\ufffe\017\ufffe\001\002" +
    "\000\020\002\ufffb\003\ufffb\013\ufffb\014\ufffb\015\ufffb\016" +
    "\ufffb\017\ufffb\001\002\000\004\023\350\001\002\000\004" +
    "\023\ufff3\001\002\000\016\013\006\014\005\015\011\016" +
    "\010\017\015\024\uffee\001\002\000\004\005\360\001\002" +
    "\000\006\024\ufff0\064\ufff0\001\002\000\004\024\357\001" +
    "\002\000\006\024\uffed\064\355\001\002\000\014\013\006" +
    "\014\005\015\011\016\010\017\015\001\002\000\006\024" +
    "\uffef\064\uffef\001\002\000\004\047\ufff9\001\002\000\006" +
    "\024\ufff1\064\ufff1\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\357\000\014\002\003\003\015\004\006\013\013\066" +
    "\011\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\050\345\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\003\015\004\006\013\343\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\054\004\026\005\050\006\046\014\020" +
    "\021\023\026\054\030\027\032\036\033\034\034\037\035" +
    "\056\036\022\042\044\043\052\044\021\045\033\050\032" +
    "\051\045\052\047\057\051\065\053\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\052\004\026\005\050\006\046\014\020\026\216\030" +
    "\027\032\036\033\034\034\037\035\056\036\022\042\044" +
    "\043\052\044\021\045\033\050\032\051\045\052\047\057" +
    "\051\065\053\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\032\007\064\014" +
    "\066\020\102\022\307\024\061\025\067\027\072\030\060" +
    "\046\076\047\062\050\032\052\074\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\055\250" +
    "\056\247\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\032" +
    "\007\064\014\066\020\102\022\100\024\061\025\067\027" +
    "\072\030\060\046\076\047\062\050\032\052\074\001\001" +
    "\000\002\001\001\000\004\023\141\001\001\000\004\031" +
    "\127\001\001\000\022\007\064\014\066\020\102\025\126" +
    "\027\072\030\060\050\032\052\074\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\032\007\064\014\066\020\102\022" +
    "\122\024\061\025\067\027\072\030\060\046\076\047\062" +
    "\050\032\052\074\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\061\112" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\026\007\064\014\066" +
    "\020\102\024\061\025\067\027\072\030\060\046\114\050" +
    "\032\052\074\001\001\000\002\001\001\000\004\061\112" +
    "\001\001\000\002\001\001\000\002\001\001\000\032\007" +
    "\064\014\066\020\102\022\120\024\061\025\067\027\072" +
    "\030\060\046\076\047\062\050\032\052\074\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\030\007\064\014\066\020\102\024\061\025\067" +
    "\027\072\030\060\046\076\047\132\050\032\052\074\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\031\127" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\024\007\064\014\066\020\102\024\142\025\067\027" +
    "\072\030\060\050\032\052\074\001\001\000\004\023\141" +
    "\001\001\000\002\001\001\000\004\053\146\001\001\000" +
    "\006\020\150\054\151\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\020\154\001\001\000\002\001\001\000\034" +
    "\007\064\014\066\020\102\022\157\024\061\025\067\027" +
    "\072\030\060\046\076\047\062\050\032\052\074\053\156" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\032\007\064\014\066\020\102" +
    "\022\163\024\061\025\067\027\072\030\060\046\076\047" +
    "\062\050\032\052\074\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\014\176\030\171\050" +
    "\032\052\175\063\167\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\032\007\064\014\066\020\102\022\177\024\061" +
    "\025\067\027\072\030\060\046\076\047\062\050\032\052" +
    "\074\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\073" +
    "\203\001\001\000\010\037\207\040\210\041\206\001\001" +
    "\000\004\064\220\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\040\212\041\206\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\075\214\001" +
    "\001\000\054\004\026\005\050\006\046\014\020\021\215" +
    "\026\054\030\027\032\036\033\034\034\037\035\056\036" +
    "\022\042\044\043\052\044\021\045\033\050\032\051\045" +
    "\052\047\057\051\065\053\001\001\000\052\004\026\005" +
    "\050\006\046\014\020\026\216\030\027\032\036\033\034" +
    "\034\037\035\056\036\022\042\044\043\052\044\021\045" +
    "\033\050\032\051\045\052\047\057\051\065\053\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\074\224\001\001" +
    "\000\054\004\026\005\050\006\046\014\020\021\225\026" +
    "\054\030\027\032\036\033\034\034\037\035\056\036\022" +
    "\042\044\043\052\044\021\045\033\050\032\051\045\052" +
    "\047\057\051\065\053\001\001\000\052\004\026\005\050" +
    "\006\046\014\020\026\216\030\027\032\036\033\034\034" +
    "\037\035\056\036\022\042\044\043\052\044\021\045\033" +
    "\050\032\051\045\052\047\057\051\065\053\001\001\000" +
    "\020\004\026\005\227\006\232\030\027\051\045\052\047" +
    "\062\231\001\001\000\002\001\001\000\002\001\001\000" +
    "\030\007\064\014\066\020\102\024\061\025\067\027\072" +
    "\030\060\046\076\047\233\050\032\052\074\001\001\000" +
    "\002\001\001\000\004\031\127\001\001\000\006\030\236" +
    "\060\235\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\032\007\064\014\066\020\102\022\241" +
    "\024\061\025\067\027\072\030\060\046\076\047\062\050" +
    "\032\052\074\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\072\244\001\001\000\054\004\026\005\050\006" +
    "\046\014\020\021\245\026\054\030\027\032\036\033\034" +
    "\034\037\035\056\036\022\042\044\043\052\044\021\045" +
    "\033\050\032\051\045\052\047\057\051\065\053\001\001" +
    "\000\052\004\026\005\050\006\046\014\020\026\216\030" +
    "\027\032\036\033\034\034\037\035\056\036\022\042\044" +
    "\043\052\044\021\045\033\050\032\051\045\052\047\057" +
    "\051\065\053\001\001\000\002\001\001\000\004\055\265" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\070" +
    "\262\001\001\000\002\001\001\000\030\007\064\014\066" +
    "\020\102\024\061\025\067\027\072\030\060\046\076\047" +
    "\255\050\032\052\074\001\001\000\004\031\127\001\001" +
    "\000\002\001\001\000\054\004\026\005\050\006\046\014" +
    "\020\021\260\026\054\030\027\032\036\033\034\034\037" +
    "\035\056\036\022\042\044\043\052\044\021\045\033\050" +
    "\032\051\045\052\047\057\051\065\053\001\001\000\052" +
    "\004\026\005\050\006\046\014\020\026\216\030\027\032" +
    "\036\033\034\034\037\035\056\036\022\042\044\043\052" +
    "\044\021\045\033\050\032\051\045\052\047\057\051\065" +
    "\053\001\001\000\002\001\001\000\054\004\026\005\050" +
    "\006\046\014\020\021\263\026\054\030\027\032\036\033" +
    "\034\034\037\035\056\036\022\042\044\043\052\044\021" +
    "\045\033\050\032\051\045\052\047\057\051\065\053\001" +
    "\001\000\052\004\026\005\050\006\046\014\020\026\216" +
    "\030\027\032\036\033\034\034\037\035\056\036\022\042" +
    "\044\043\052\044\021\045\033\050\032\051\045\052\047" +
    "\057\051\065\053\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\030\007\064\014\066\015\270" +
    "\016\271\017\273\020\102\025\272\027\072\030\060\050" +
    "\032\052\074\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\024\007\064\014\066\015\276\020\102\025\272\027\072" +
    "\030\060\050\032\052\074\001\001\000\002\001\001\000" +
    "\030\007\064\014\066\020\102\024\061\025\067\027\072" +
    "\030\060\046\076\047\300\050\032\052\074\001\001\000" +
    "\004\031\127\001\001\000\002\001\001\000\004\071\303" +
    "\001\001\000\054\004\026\005\050\006\046\014\020\021" +
    "\304\026\054\030\027\032\036\033\034\034\037\035\056" +
    "\036\022\042\044\043\052\044\021\045\033\050\032\051" +
    "\045\052\047\057\051\065\053\001\001\000\052\004\026" +
    "\005\050\006\046\014\020\026\216\030\027\032\036\033" +
    "\034\034\037\035\056\036\022\042\044\043\052\044\021" +
    "\045\033\050\032\051\045\052\047\057\051\065\053\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\032\007\064\014\066\020\102\022\323" +
    "\024\061\025\067\027\072\030\060\046\076\047\062\050" +
    "\032\052\074\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\032\007\064\014\066\020\102\022\327\024" +
    "\061\025\067\027\072\030\060\046\076\047\062\050\032" +
    "\052\074\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\030" +
    "\007\064\014\066\020\102\024\061\025\067\027\072\030" +
    "\060\046\076\047\335\050\032\052\074\001\001\000\004" +
    "\031\127\001\001\000\002\001\001\000\004\067\340\001" +
    "\001\000\054\004\026\005\050\006\046\014\020\021\341" +
    "\026\054\030\027\032\036\033\034\034\037\035\056\036" +
    "\022\042\044\043\052\044\021\045\033\050\032\051\045" +
    "\052\047\057\051\065\053\001\001\000\052\004\026\005" +
    "\050\006\046\014\020\026\216\030\027\032\036\033\034" +
    "\034\037\035\056\036\022\042\044\043\052\044\021\045" +
    "\033\050\032\051\045\052\047\057\051\065\053\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\004\350\010\351" +
    "\011\353\012\352\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\004\350" +
    "\010\355\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


    
    private Symbol s;
  
    //Lista de errores sintácticos controlados
    public List<String> errorList = new ArrayList<>();

    //Lista de errores semánticos 
    public List<String> semanticErrorList = new ArrayList<>();
    
    // Agrega errores controlados a la lista
    public void logError(Symbol s) {
        String error = "Error cerca de Linea: " + (s.right + 1) + " Columna: " + (s.left + 1) + ", Texto: \"" + s.value + "\"";
        errorList.add(error);
    }

    // Agrega errores semánticos a la lista
    public void logSemanticError(String error) {
        semanticErrorList.add(error);
    }

    // Agrega errores controlados a la lista
    public void logError(String error) {
        errorList.add(error);
    }

    // Obtiene la lista de errores sintácticos controlados
    public List<String> getErrorList() {
        return errorList;
    }

    // Obtiene la lista de errores semánticos 
    public List<String> getSemanticErrorList() {
        return semanticErrorList;
    }

    // Gestiona errores recuperables -error-
    public void syntax_error(Symbol s){
        this.s = s;
        logError(s);
    }

    // Gestiona errores no recuperables
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        String error = "\nError no recuperable:\n No se encontró final de sentencia (finregalo), \n o no se encontró final de bloque (cierracuento) \n o se determinó un error desconocido ";
        errorList.add(error);
    }

    // Método para obtener el Symbol donde se generó el error.
    public Symbol getS(){
        return this.s;
    }

    //Método para salida por consolda
    public void print(String prodName, Symbol s){
         String salida = "Encontrado " +prodName+ " : cerca de Linea: " + (s.right + 1) + " Columna: " + (s.left + 1) + ", Texto: \"" + s.value + "\"";
         System.out.println(salida); 
    }

    public Object getSymbolTable() {
        return this.action_obj.symbolTable;
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {

     
    String currentHash;
    String currentFunction;
    String currentSwitch;
    public SymbolTable symbolTable = new SymbolTable();

  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // BREAK_STATEMENT ::= Break EndSentence 
            {
              Object RESULT =null;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BREAK_EXPRESSION,
                                                    null,
                                                    "Break-Statement"
                                                ); 
                        RESULT = expressionNode; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BREAK_STATEMENT",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // RETURN_STATEMENT ::= Return EXPRESSION EndSentence 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RETURN_EXPRESSION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                                ); 
                        RESULT = new ReturnStatementNode(expressionNode); 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN_STATEMENT",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // RETURN_STATEMENT ::= Return EndSentence 
            {
              Object RESULT =null;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RETURN_EXPRESSION,
                                                    null,
                                                    "Retorno Vacío"
                                                ); 
                        RESULT = new ReturnStatementNode(expressionNode);  
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN_STATEMENT",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // CASE_LABEL ::= CharacterLiteral 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LITERALS,
                                                    null,
                                                    "Char:" + exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASE_LABEL",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // CASE_LABEL ::= IntegerLiteral 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LITERALS,
                                                    null,
                                                    "Integer:" + exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASE_LABEL",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // CASE_LABEL ::= Identifier 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.IDENTIFIER,
                                                     null,
                                                    " Id:" +exp.toString() + " "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASE_LABEL",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // SWITCH_EXPRESSION ::= ParenthesisOpening EXPRESSION ParenthesisClosure 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.SIMPLE_EXPRESSION,
                                                    (ExpressionNode)exp,
                                                    " ( " + ((ExpressionNode)exp).toString() + " ) "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // SWITCH_EXPRESSION ::= UNARY_ARITHMETIC_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.UNARY_ARITHMETIC_EXPRESSION,
                                                    null,
                                                    exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // SWITCH_EXPRESSION ::= FUNCTION_CALL 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.FUNCTION_CALL_AS_EXPRESSION,
                                                    null,
                                                    ((FunctionCallNode)exp).name+"( " + ((FunctionCallNode)exp).parameterList.toString() +" )",
                                                    (ASTNode)exp
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // SWITCH_EXPRESSION ::= ARRAY_USE 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.ARRAY_USE_AS_EXPRESSION,
                                                    null,
                                                    ((ArrayUseNode)exp).id+"[ " + ((ExpressionNode)((ArrayUseNode)exp).expression).expression  +" ]",
                                                    (ASTNode)exp
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // SWITCH_EXPRESSION ::= CharacterLiteral 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LITERALS,
                                                    null,
                                                    "Char:" + exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // SWITCH_EXPRESSION ::= IntegerLiteral 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LITERALS,
                                                    null,
                                                    "Integer:" + exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // SWITCH_EXPRESSION ::= Identifier 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.IDENTIFIER,
                                                     null,
                                                    " Id:" +exp.toString() + " "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_EXPRESSION",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // DEFAULT_CASE ::= Default Colon NT$6 FUNCTION_DECLARATION_BODY 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                     ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.CASE_LABEL,
                                                    null,
                                                    "Default"
                                                );
                     RESULT = new SwitchCaseNode("Default", expressionNode, (List<BodyNode>)body);

                     symbolTable.exitBlock(); 
                     currentHash = symbolTable.getCurrentBlockIdentifier(); 
               
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFAULT_CASE",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // NT$6 ::= 
            {
              Object RESULT =null;
 
                     symbolTable.enterBlock(currentSwitch, "default"); 
                     currentHash = symbolTable.getCurrentBlockIdentifier();       
               
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",59, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // CASE ::= DEFAULT_CASE 
            {
              Object RESULT =null;
		int defaultCaseleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int defaultCaseright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object defaultCase = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                RESULT = (SwitchCaseNode)defaultCase; 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASE",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // CASE ::= Case CASE_LABEL Colon NT$5 FUNCTION_DECLARATION_BODY 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.CASE_LABEL,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                                ); 
                    RESULT = new SwitchCaseNode("Case", expressionNode, (List<BodyNode>)body);

                    symbolTable.exitBlock(); 
                    currentHash = symbolTable.getCurrentBlockIdentifier(); 
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASE",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // NT$5 ::= 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
 
                    symbolTable.enterBlock(currentSwitch, "case"); 
                    currentHash = symbolTable.getCurrentBlockIdentifier();       
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // CASES ::= CASES CASE 
            {
              Object RESULT =null;
		int caseListleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int caseListright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object caseList = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int caseNodeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int caseNoderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object caseNode = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                RESULT = (List<SwitchCaseNode>) caseList;
               ((List<SwitchCaseNode>) RESULT).add((SwitchCaseNode)caseNode);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASES",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // CASES ::= CASE 
            {
              Object RESULT =null;
		int caseNodeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int caseNoderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object caseNode = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                RESULT = new ArrayList<SwitchCaseNode>(); 
                ((List<SwitchCaseNode>)RESULT).add((SwitchCaseNode)caseNode);
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CASES",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // SWITCH_STRUCTURE ::= Switch ParenthesisOpening SWITCH_EXPRESSION ParenthesisClosure BlockOpening NT$4 CASES BlockClosure 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int caseListleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int caseListright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object caseList = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.SWITCH_EXPRESSION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                                ); 
                         RESULT = new SwitchStatementNode(expressionNode, (List<SwitchCaseNode>)caseList);

                         symbolTable.exitBlock(); 
                         currentHash = symbolTable.getCurrentBlockIdentifier(); 
                   
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SWITCH_STRUCTURE",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // NT$4 ::= 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 
                         symbolTable.enterBlock(currentFunction, "switch"); 
                         currentHash = symbolTable.getCurrentBlockIdentifier();
                         currentSwitch = currentHash;
                   
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",57, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // UPDATE_EXPRESSION ::= Identifier AssignmentSign EXPRESSION 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.UPDATE_EXPRESSION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                                ); 
                        RESULT = new VariableAssignmentNode(id.toString(), expressionNode);  
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("UPDATE_EXPRESSION",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // UPDATE_EXPRESSION ::= UNARY_ARITHMETIC_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                        RESULT = new VariableAssignmentNode(exp.toString()); 
                      
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("UPDATE_EXPRESSION",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // INIT_FOR_STRUCTURE ::= VARIABLE_ASSIGNMENT 
            {
              Object RESULT =null;
		int varAssigleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int varAssigright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object varAssig = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = varAssig; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_FOR_STRUCTURE",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // INIT_FOR_STRUCTURE ::= VARIABLE_DECLARATION 
            {
              Object RESULT =null;
		int varDeclleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int varDeclright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object varDecl = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT =  varDecl; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INIT_FOR_STRUCTURE",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // FOR_STRUCTURE ::= For ParenthesisOpening INIT_FOR_STRUCTURE LOGICAL_EXPRESSION EndSentence UPDATE_EXPRESSION ParenthesisClosure BlockOpening NT$3 FUNCTION_DECLARATION_BODY BlockClosure 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-8)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int updateExpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int updateExpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object updateExp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                      ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.CONTROL_STRUCTURE_CONDITION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                                ); 
                      RESULT = new ForStatementNode((ASTNode)init, expressionNode, (VariableAssignmentNode)updateExp, (List<BodyNode>)body);

                      symbolTable.exitBlock(); 
                      currentHash = symbolTable.getCurrentBlockIdentifier(); 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR_STRUCTURE",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // NT$3 ::= 
            {
              Object RESULT =null;
		int initleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int initright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object init = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int updateExpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int updateExpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object updateExp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 
                      symbolTable.enterBlock(currentFunction, "for"); 
                      currentHash = symbolTable.getCurrentBlockIdentifier();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // WHILE_STRUCTURE ::= While ParenthesisOpening LOGICAL_EXPRESSION ParenthesisClosure BlockOpening NT$2 FUNCTION_DECLARATION_BODY BlockClosure 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.CONTROL_STRUCTURE_CONDITION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                                ); 
                        RESULT = new WhileStatementNode(expressionNode,( List<BodyNode>)body);

                        symbolTable.exitBlock(); 
                        currentHash = symbolTable.getCurrentBlockIdentifier(); 
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("WHILE_STRUCTURE",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // NT$2 ::= 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 
                        symbolTable.enterBlock(currentFunction, "while"); 
                        currentHash = symbolTable.getCurrentBlockIdentifier(); 
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",55, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // IF_ELSE_STRUCTURE_TYPE ::= IF_STRUCTURE ELSE_IF_STRUCTURE 
            {
              Object RESULT =null;
		int ifNodeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ifNoderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object ifNode = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int elseIfChainleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elseIfChainright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object elseIfChain = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                              RESULT = new IfStatementNode((IfStatementNode)ifNode, (List<IfStatementNode>)elseIfChain, 3); 
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_ELSE_STRUCTURE_TYPE",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // IF_ELSE_STRUCTURE_TYPE ::= IF_STRUCTURE ELSE_STRUCTURE 
            {
              Object RESULT =null;
		int ifNodeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ifNoderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object ifNode = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int elseBodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elseBodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object elseBody = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                              RESULT = new IfStatementNode((IfStatementNode)ifNode, (List<BodyNode>)elseBody); 
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_ELSE_STRUCTURE_TYPE",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // IF_ELSE_STRUCTURE_TYPE ::= IF_STRUCTURE 
            {
              Object RESULT =null;
		int ifNodeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ifNoderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object ifNode = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                              RESULT = (IfStatementNode)ifNode; 
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_ELSE_STRUCTURE_TYPE",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // ELSE_IF_STRUCTURE ::= ELSE_IF_STRUCTURE ELSE_STRUCTURE 
            {
              Object RESULT =null;
		int elIfChainleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elIfChainright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object elIfChain = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int elseBodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elseBodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object elseBody = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                            ((ArrayList<IfStatementNode>)elIfChain).add(new IfStatementNode((List<BodyNode>)elseBody));//caso 4 IfStatementNode
                            RESULT = (ArrayList<IfStatementNode>)elIfChain; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ELSE_IF_STRUCTURE",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // ELSE_IF_STRUCTURE ::= Else If ParenthesisOpening LOGICAL_EXPRESSION ParenthesisClosure BlockOpening FUNCTION_DECLARATION_BODY BlockClosure 
            {
              Object RESULT =null;
		int conditionleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int conditionright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object condition = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int thenBodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int thenBodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object thenBody = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            RESULT = new ArrayList<IfStatementNode>();
                            ((ArrayList<IfStatementNode>)RESULT).add(new IfStatementNode((ExpressionNode)condition, (List<BodyNode>)thenBody));
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ELSE_IF_STRUCTURE",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // ELSE_STRUCTURE ::= Else BlockOpening NT$1 FUNCTION_DECLARATION_BODY BlockClosure 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int elseBodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elseBodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object elseBody = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		                     
                        symbolTable.exitBlock(); 
                        currentHash = symbolTable.getCurrentBlockIdentifier(); 
                        RESULT = (List<BodyNode>)elseBody;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ELSE_STRUCTURE",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // NT$1 ::= 
            {
              Object RESULT =null;
 
                        symbolTable.enterBlock(currentFunction, "else"); 
                        currentHash = symbolTable.getCurrentBlockIdentifier();
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // IF_STRUCTURE ::= If ParenthesisOpening LOGICAL_EXPRESSION ParenthesisClosure BlockOpening NT$0 FUNCTION_DECLARATION_BODY BlockClosure 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int thenBodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int thenBodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object thenBody = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                   symbolTable.exitBlock(); 
                   currentHash = symbolTable.getCurrentBlockIdentifier(); 

                   ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.CONTROL_STRUCTURE_CONDITION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                            ); 
                   RESULT = new IfStatementNode(expressionNode, (List<BodyNode>)thenBody);
               
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_STRUCTURE",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // NT$0 ::= 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 
                    symbolTable.enterBlock(currentFunction, "if"); 
                    currentHash = symbolTable.getCurrentBlockIdentifier();
               
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // CONTROL_STRUCTURE ::= SWITCH_STRUCTURE 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (ASTNode)c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONTROL_STRUCTURE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // CONTROL_STRUCTURE ::= FOR_STRUCTURE 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (ASTNode)c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONTROL_STRUCTURE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // CONTROL_STRUCTURE ::= WHILE_STRUCTURE 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (ASTNode)c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONTROL_STRUCTURE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // CONTROL_STRUCTURE ::= IF_ELSE_STRUCTURE_TYPE 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (ASTNode)c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONTROL_STRUCTURE",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // VARIABLE_ASSIGNMENT ::= ARRAY_USE AssignmentSign EXPRESSION EndSentence 
            {
              Object RESULT =null;
		int arrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int arrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object arr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.ARRAY_USE_EXPRESSION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                        ); 
                            RESULT = new VariableAssignmentNode((ArrayUseNode)arr, expressionNode); 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_ASSIGNMENT",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // VARIABLE_ASSIGNMENT ::= Identifier AssignmentSign ARRAY_ELEMENTS EndSentence 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int elementsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elementsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object elements = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            RESULT = new VariableAssignmentNode(id.toString(), (ArrayElementsNode)elements);
                            try {
                                ((VariableAssignmentNode) RESULT).parser = parser;
                                ((VariableAssignmentNode) RESULT).currentHash = currentHash;
                                ((VariableAssignmentNode) RESULT).checkSemantics();
                                symbolTable.updateVariableValue(id.toString(), currentHash, elements);

                            } catch (RuntimeException e) {
                                String message = e.getMessage();

                                if (message.contains("ya está definida.")) {
                                    System.out.println(message);
                                } else {
                                    parser.logSemanticError("Error en la línea " + (idright+1) + ": " + message);
                                }
                            }
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_ASSIGNMENT",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // VARIABLE_ASSIGNMENT ::= UNARY_ARITHMETIC_EXPRESSION EndSentence 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            RESULT = new VariableAssignmentNode(exp.toString());
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_ASSIGNMENT",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // VARIABLE_ASSIGNMENT ::= Identifier AssignmentSign EXPRESSION EndSentence 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.VARIABLE_ASSIGNMENT_EXPRESSION,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                            ); 
                            RESULT = new VariableAssignmentNode(id.toString(), expressionNode);
                            try {
                                ((VariableAssignmentNode) RESULT).parser = parser;
                                ((VariableAssignmentNode) RESULT).currentHash = currentHash;
                                ((VariableAssignmentNode) RESULT).checkSemantics();
                                symbolTable.updateVariableValue(id.toString(), currentHash, exp.toString());

                            } catch (RuntimeException e) {
                                String message = e.getMessage();

                                if (message.contains("ya está definida.")) {
                                    System.out.println(message);
                                } else {
                                    parser.logSemanticError("Error en la línea " + (idright+1) + ": " + message);
                                }
                            }
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_ASSIGNMENT",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // LOGICAL_EXPRESSION ::= LOGICAL_EXPRESSION LOGICAL_OPERATOR LOGICAL_EXPRESSION 
            {
              Object RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                            ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LOGICAL,
                                                    ((ASTNode) exp1).toString() + ((ASTNode) op).toString()  + ((ASTNode) exp2).toString() ,
                                                    (ASTNode) exp1,
                                                    (ASTNode) op,
                                                    (ASTNode) exp2
                                            ); 
                            RESULT = expressionNode;
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOGICAL_EXPRESSION",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // LOGICAL_EXPRESSION ::= RELATIONAL_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                            RESULT = (ExpressionNode)exp; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOGICAL_EXPRESSION",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // LOGICAL_OPERATOR ::= Disjunction 
            {
              Object RESULT =null;
		 
                         ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LOGICAL_OPERATOR_DISJUCTION,
                                                    null,
                                                    " || "
                                            ); 
                        RESULT = expressionNode; 
                     
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOGICAL_OPERATOR",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // LOGICAL_OPERATOR ::= Conjunction 
            {
              Object RESULT =null;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LOGICAL_OPERATOR_CONJUNCTION,
                                                    null,
                                                    " && "
                                            ); 
                        RESULT = expressionNode; 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LOGICAL_OPERATOR",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // RELATIONAL_EXPRESSION ::= RELATIONAL_EXPRESSION RELATIONAL_OPERATOR RELATIONAL_EXPRESSION 
            {
              Object RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                           ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_EXPRESSION,
                                                    ((ASTNode) exp1).toString()  + ((ASTNode) op).toString()  + ((ASTNode) exp2).toString() ,
                                                    (ASTNode) exp1,
                                                    (ASTNode) op,
                                                    (ASTNode) exp2
                                            ); 
                           RESULT = expressionNode; 
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_EXPRESSION",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // RELATIONAL_EXPRESSION ::= ARITHMETIC_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                            RESULT = (ASTNode)exp; 
                          
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_EXPRESSION",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // RELATIONAL_OPERATOR ::= NotEqual 
            {
              Object RESULT =null;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_OPERATOR_NOT_EQUAL,
                                                    null,
                                                    " != "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_OPERATOR",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // RELATIONAL_OPERATOR ::= Equal 
            {
              Object RESULT =null;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_OPERATOR_EQUAL,
                                                    null,
                                                    " == "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_OPERATOR",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // RELATIONAL_OPERATOR ::= GreaterEqual 
            {
              Object RESULT =null;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_OPERATOR_GREATER_EQUAL,
                                                    null,
                                                    " >= "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_OPERATOR",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // RELATIONAL_OPERATOR ::= Greater 
            {
              Object RESULT =null;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_OPERATOR_GREATER,
                                                    null,
                                                    " > "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_OPERATOR",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // RELATIONAL_OPERATOR ::= LessEqual 
            {
              Object RESULT =null;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_OPERATOR_LESS_EQUAL,
                                                    null,
                                                    " <= "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_OPERATOR",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // RELATIONAL_OPERATOR ::= Less 
            {
              Object RESULT =null;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.RELATIONAL_OPERATOR_LESS,
                                                    null,
                                                    " < "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RELATIONAL_OPERATOR",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ARITHMETIC_EXPRESSION ::= ARITHMETIC_EXPRESSION BINARY_ARITHMETIC_OPERATOR ARITHMETIC_EXPRESSION 
            {
              Object RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp1 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object op = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.ARITHMETIC_EXPRESSION,
                                                    ((ASTNode) exp1).toString() + ((ASTNode) op).toString() + ((ASTNode) exp2).toString(),
                                                    (ASTNode) exp1,
                                                    (ASTNode) op,
                                                    (ASTNode) exp2
                                            ); 
                                RESULT = expressionNode; 
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARITHMETIC_EXPRESSION",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ARITHMETIC_EXPRESSION ::= SIMPLE_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                                RESULT = exp; 
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARITHMETIC_EXPRESSION",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // SIMPLE_EXPRESSION ::= Negation SIMPLE_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.NEGATION_SIMPLE_EXPRESSION,
                                                    (ExpressionNode) exp,
                                                    " -" +((ExpressionNode) exp).toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // SIMPLE_EXPRESSION ::= ParenthesisOpening EXPRESSION ParenthesisClosure 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.SIMPLE_EXPRESSION,
                                                    (ExpressionNode)exp,
                                                    " ( " + ((ExpressionNode)exp).toString() + " ) "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // SIMPLE_EXPRESSION ::= UNARY_ARITHMETIC_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.UNARY_ARITHMETIC_EXPRESSION,
                                                    null,
                                                    exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // SIMPLE_EXPRESSION ::= FUNCTION_CALL 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.FUNCTION_CALL_AS_EXPRESSION,
                                                    null,
                                                    ((FunctionCallNode)exp).name+"( " + ((FunctionCallNode)exp).parameterList.toString() +" )",
                                                    (ASTNode)exp
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // SIMPLE_EXPRESSION ::= ARRAY_USE 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.ARRAY_USE_AS_EXPRESSION,
                                                    null,
                                                    ((ArrayUseNode)exp).id+"[ " + ((ExpressionNode)((ArrayUseNode)exp).expression).expression  +" ]",
                                                    (ASTNode)exp
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // SIMPLE_EXPRESSION ::= NEGATIVE_LITERAL 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.NEGATIVE_LITERAL,
                                                    null,
                                                    exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // SIMPLE_EXPRESSION ::= LITERALS 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.LITERALS,
                                                    null,
                                                    exp.toString()
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // SIMPLE_EXPRESSION ::= Identifier 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.IDENTIFIER,
                                                     null,
                                                    " Id:" +exp.toString() + " "
                                            );  
                        RESULT = expressionNode; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIMPLE_EXPRESSION",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // EXPRESSION ::= LOGICAL_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    RESULT = (ExpressionNode)exp; 
                    
                    try {
                        ((ExpressionNode) RESULT).parser = parser;
                        ((ExpressionNode) RESULT).currentHash = currentHash;
                        ((ExpressionNode) RESULT).checkSemantics();

                    } catch (RuntimeException e) {
                        String message = e.getMessage();
                        parser.logSemanticError("Error en la línea " + (expright+1) + ": " + message);                           
                    }                    
             
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPRESSION",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // UNARY_ARITHMETIC_EXPRESSION ::= Identifier Decrement 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = id.toString()+ ":" + "--"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("UNARY_ARITHMETIC_EXPRESSION",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // UNARY_ARITHMETIC_EXPRESSION ::= Identifier Increment 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = id.toString()+":" +  "++"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("UNARY_ARITHMETIC_EXPRESSION",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NEGATIVE_LITERAL ::= NEGATIVE_OPERATOR FloatLiteral 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "NEGATIVE-"+lit.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NEGATIVE_LITERAL",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // NEGATIVE_LITERAL ::= NEGATIVE_OPERATOR IntegerLiteral 
            {
              Object RESULT =null;
		int litleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int litright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object lit = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "NEGATIVE-"+lit.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NEGATIVE_LITERAL",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // FUNCTION_CALL_EXPRESSION ::= FUNCTION_CALL EndSentence 
            {
              Object RESULT =null;
		int funcleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int funcright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object func = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = (ASTNode)func; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL_EXPRESSION",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // FUNCTION_CALL ::= FUNCTION_NAME ParenthesisOpening FUNCTION_CALL_PARAMETER_OPTION ParenthesisClosure 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int parametersleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int parametersright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object parameters = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        RESULT = new FunctionCallNode(name.toString(), (List<ExpressionNode>)parameters);
                        //System.out.println((parametersright+1) + " LLamada a funcion " + name + " con los parametros: " + parameters.toString());

                        try {
                            ((FunctionCallNode) RESULT).parser = parser;
                            ((FunctionCallNode) RESULT).currentHash = currentFunction;
                            ((FunctionCallNode) RESULT).checkSemantics();

                        } catch (RuntimeException e) {
                            String message = e.getMessage();
                            parser.logSemanticError("Error en la línea " + (parametersright+1) + ": " + message);                           
                        }

                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // FUNCTION_CALL_PARAMETER_OPTION ::= FUNCTION_CALL_PARAMETER_LIST 
            {
              Object RESULT =null;
		int parametersleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int parametersright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object parameters = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (List<ExpressionNode>)parameters; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL_PARAMETER_OPTION",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FUNCTION_CALL_PARAMETER_OPTION ::= 
            {
              Object RESULT =null;
		 RESULT = new ArrayList<ExpressionNode>(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL_PARAMETER_OPTION",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // FUNCTION_CALL_PARAMETER_LIST ::= FUNCTION_CALL_PARAMETER_LIST Comma FUNCTION_CALL_PARAMETER 
            {
              Object RESULT =null;
		int paramListleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int paramListright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object paramList = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.FUNCTION_CALL_PARAMETER,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                        ); 
                                        ((List<ExpressionNode>)paramList).add(expressionNode);
                                        RESULT = (List<ExpressionNode>)paramList; 
                                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL_PARAMETER_LIST",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // FUNCTION_CALL_PARAMETER_LIST ::= FUNCTION_CALL_PARAMETER 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                                        ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.FUNCTION_CALL_PARAMETER,
                                                    (ASTNode) exp,
                                                    ((ASTNode) exp).toString()
                                        ); 
                                        RESULT = new ArrayList<ExpressionNode>(); 
                                        ((List<ExpressionNode>)RESULT).add(expressionNode);
                                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL_PARAMETER_LIST",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // FUNCTION_CALL_PARAMETER ::= SIMPLE_EXPRESSION 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_CALL_PARAMETER",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // NEGATIVE_OPERATOR ::= Negative 
            {
              Object RESULT =null;
		 RESULT = "-"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NEGATIVE_OPERATOR",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // BINARY_ARITHMETIC_OPERATOR ::= Power 
            {
              Object RESULT =null;
		
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BINARY_ARITHMETIC_OPERATOR_POWER,
                                                    null,
                                                    " ** "
                                            ); 
                                RESULT = expressionNode; 
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BINARY_ARITHMETIC_OPERATOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // BINARY_ARITHMETIC_OPERATOR ::= Module 
            {
              Object RESULT =null;
		
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BINARY_ARITHMETIC_OPERATOR_MODULE,
                                                    null,
                                                    " % "
                                            ); 
                                RESULT = expressionNode; 
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BINARY_ARITHMETIC_OPERATOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // BINARY_ARITHMETIC_OPERATOR ::= Division 
            {
              Object RESULT =null;
		
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BINARY_ARITHMETIC_OPERATOR_DIVISION,
                                                    null,
                                                    " / "
                                            ); 
                                RESULT = expressionNode; 
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BINARY_ARITHMETIC_OPERATOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // BINARY_ARITHMETIC_OPERATOR ::= Multiplication 
            {
              Object RESULT =null;
		
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BINARY_ARITHMETIC_OPERATOR_MULTIPLICATION,
                                                    null,
                                                    " * "
                                            ); 
                                RESULT = expressionNode; 
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BINARY_ARITHMETIC_OPERATOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // BINARY_ARITHMETIC_OPERATOR ::= Subtraction 
            {
              Object RESULT =null;
		
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BINARY_ARITHMETIC_OPERATOR_SUBTRACTION,
                                                    null,
                                                    " - "
                                            ); 
                                RESULT = expressionNode; 
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BINARY_ARITHMETIC_OPERATOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // BINARY_ARITHMETIC_OPERATOR ::= Sum 
            {
              Object RESULT =null;
		
                                ExpressionNode expressionNode = new ExpressionNode(
                                                    ExpressionEnum.BINARY_ARITHMETIC_OPERATOR_SUM,
                                                    null,
                                                    " + "
                                            ); 
                                RESULT = expressionNode; 
                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BINARY_ARITHMETIC_OPERATOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // READ_STATEMENT ::= Read ParenthesisOpening EXPRESSION ParenthesisClosure EndSentence 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                        ExpressionNode expressionNode = new ExpressionNode(
                                                ExpressionEnum.READ_EXPRESSION,
                                                (ASTNode) exp,
                                                ((ASTNode) exp).toString()
                                        ); 
                        RESULT = new ReadFunctionCallNode(expressionNode); 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("READ_STATEMENT",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // PRINT_STATEMENT ::= Print ParenthesisOpening EXPRESSION ParenthesisClosure EndSentence 
            {
              Object RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
                    ExpressionNode expressionNode = new ExpressionNode(
                                ExpressionEnum.PRINT_EXPRESSION,
                                (ASTNode) exp,
                                ((ASTNode) exp).toString()
                    ); 
                    RESULT = new PrintFunctionCallNode(expressionNode); 
                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PRINT_STATEMENT",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // LITERALS ::= StringLiteral 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "String:" + s.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERALS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // LITERALS ::= CharacterLiteral 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "Char:" + c.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERALS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // LITERALS ::= BoolLiteral 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "Bool:" + b.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERALS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // LITERALS ::= FloatLiteral 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "Float:" + f.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERALS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // LITERALS ::= IntegerLiteral 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = "Integer:" + i.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERALS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // LITERAL_LIST ::= LITERAL_LIST Comma LITERALS 
            {
              Object RESULT =null;
		int listleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object list = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int literalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int literalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object literal = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    ((List<String>)list).add(literal.toString()); 
                    RESULT = list; 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERAL_LIST",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // LITERAL_LIST ::= LITERALS 
            {
              Object RESULT =null;
		int literalleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int literalright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object literal = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                    RESULT = new ArrayList<String>();
                    ((List<String>)RESULT).add(literal.toString()); 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LITERAL_LIST",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // ARRAY_USE ::= Identifier BracketOpening EXPRESSION BracketClosure 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                    ExpressionNode expressionNode = new ExpressionNode(
                                ExpressionEnum.ARRAY_USE_EXPRESSION,
                                (ASTNode) exp,
                                ((ASTNode) exp).toString()
                    );
                    RESULT = new ArrayUseNode(id.toString(), expressionNode); 
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARRAY_USE",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // ARRAY_DECLARATION ::= VARIABLE_TYPE Identifier BracketOpening Identifier BracketClosure 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int sizeIdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sizeIdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object sizeId = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        RESULT =  new ArrayDeclarationNode(type.toString(), id.toString(), sizeId.toString());                       

                        try {
                            ((ArrayDeclarationNode) RESULT).parser = parser;
                            ((ArrayDeclarationNode) RESULT).currentHash = currentFunction;
                            ((ArrayDeclarationNode) RESULT).checkSemantics();
                            symbolTable.addVariable(id.toString(), type.toString() + "[]", currentHash, null, typeright + 1);

                        } catch (RuntimeException e) {
                            String message = e.getMessage();

                            if (message.contains("ya está definida.")) {
                                System.out.println(message);
                            } else {
                                parser.logSemanticError("Error en la línea " + (typeright+1) + ": " + message);
                            }
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARRAY_DECLARATION",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // ARRAY_DECLARATION ::= VARIABLE_TYPE Identifier BracketOpening IntegerLiteral BracketClosure 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int sizeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sizeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object size = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        RESULT =  new ArrayDeclarationNode(type.toString(), id.toString(),size.toString());                    

                        try {
                            ((ArrayDeclarationNode) RESULT).parser = parser;
                            ((ArrayDeclarationNode) RESULT).currentHash = currentFunction;
                            ((ArrayDeclarationNode) RESULT).checkSemantics();
                            symbolTable.addVariable(id.toString(), type.toString() + "[" + size + "]", currentHash, null, typeright + 1);

                        } catch (RuntimeException e) {
                            String message = e.getMessage();

                            if (message.contains("ya está definida.")) {
                                System.out.println(message);
                            } else {
                                parser.logSemanticError("Error en la línea " + (typeright+1) + ": " + message);
                            }
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARRAY_DECLARATION",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // ARRAY_DECLARATION ::= VARIABLE_TYPE Identifier BracketOpening BracketClosure 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
                        RESULT = new ArrayDeclarationNode(type.toString(), id.toString());                         

                        try {
                            ((ArrayDeclarationNode) RESULT).parser = parser;
                            ((ArrayDeclarationNode) RESULT).currentHash = currentFunction;
                            ((ArrayDeclarationNode) RESULT).checkSemantics();
                            symbolTable.addVariable(id.toString(), type.toString() + "[]", currentHash, null, typeright + 1);

                        } catch (RuntimeException e) {
                            String message = e.getMessage();

                            if (message.contains("ya está definida.")) {
                                System.out.println(message);
                            } else {
                                parser.logSemanticError("Error en la línea " + (typeright+1) + ": " + message);
                            }
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARRAY_DECLARATION",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // ARRAY_ELEMENTS ::= BlockOpening LITERAL_LIST BlockClosure 
            {
              Object RESULT =null;
		int listleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object list = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                        RESULT = new ArrayElementsNode((List<String>)list); 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARRAY_ELEMENTS",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // VARIABLE_DECLARATION ::= ARRAY_DECLARATION AssignmentSign ARRAY_ELEMENTS EndSentence 
            {
              Object RESULT =null;
		int arrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int arrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object arr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int elementsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elementsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object elements = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            RESULT =  new ArrayDeclarationNode((ArrayDeclarationNode)arr,(ArrayElementsNode)elements); 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_DECLARATION",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // VARIABLE_DECLARATION ::= ARRAY_DECLARATION EndSentence 
            {
              Object RESULT =null;
		int arrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int arrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object arr = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                            RESULT =  (ArrayDeclarationNode)arr; 
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_DECLARATION",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // VARIABLE_DECLARATION ::= VARIABLE_TYPE Identifier AssignmentSign EXPRESSION EndSentence 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            ExpressionNode expressionNode = new ExpressionNode(
                                ExpressionEnum.VARIABLE_DECLARATION_EXPRESSION,
                                (ASTNode) exp,
                                ((ASTNode) exp).toString()
                            );

                            RESULT = new VariableDeclarationNode(type.toString(), id.toString(), expressionNode);

                            try {
                                ((VariableDeclarationNode) RESULT).parser = parser;
                                ((VariableDeclarationNode) RESULT).currentHash = currentFunction;
                                ((VariableDeclarationNode) RESULT).checkSemantics();
                                symbolTable.addVariable(id.toString(), type.toString(), currentHash, exp.toString(), typeright + 1);

                            } catch (RuntimeException e) {
                                String message = e.getMessage();

                                if (message.contains("ya está definida.")) {
                                    System.out.println(message);
                                } else {
                                    parser.logSemanticError("Error en la línea " + (typeright+1) + ": " + message);
                                }
                            }                           
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_DECLARATION",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // VARIABLE_DECLARATION ::= VARIABLE_TYPE Identifier EndSentence 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 
                            RESULT = new VariableDeclarationNode(type.toString(), id.toString());

                            try {
                                ((VariableDeclarationNode) RESULT).parser = parser;
                                ((VariableDeclarationNode) RESULT).currentHash = currentFunction;
                                ((VariableDeclarationNode) RESULT).checkSemantics();
                                symbolTable.addVariable(id.toString(), type.toString(), currentHash, null, typeright + 1);

                            } catch (RuntimeException e) {
                                String message = e.getMessage();

                                if (message.contains("ya está definida.")) {
                                    System.out.println(message);
                                } else {
                                    parser.logSemanticError("Error en la línea " + (typeright+1) + ": " + message);
                                }
                            }                        
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_DECLARATION",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // FUNCTION_BODY_ELEMENT ::= error 
            {
              Object RESULT =null;
		 RESULT = new BodyNode("ERROR", new GenericASTNode("Error de sintaxis en esta posición") ); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // FUNCTION_BODY_ELEMENT ::= BREAK_STATEMENT 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("BREAK-Declaración", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // FUNCTION_BODY_ELEMENT ::= RETURN_STATEMENT 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("RETURN-Declaración", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // FUNCTION_BODY_ELEMENT ::= READ_STATEMENT 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("READ-Llamada-Función", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // FUNCTION_BODY_ELEMENT ::= PRINT_STATEMENT 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("PRINT-LLamada-Función", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // FUNCTION_BODY_ELEMENT ::= CONTROL_STRUCTURE 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("ESTRUCTURA DE CONTROL", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // FUNCTION_BODY_ELEMENT ::= FUNCTION_CALL_EXPRESSION 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("FUNCIÓN-Llamada", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // FUNCTION_BODY_ELEMENT ::= VARIABLE_ASSIGNMENT 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("VARIABLE-Asignación", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // FUNCTION_BODY_ELEMENT ::= VARIABLE_DECLARATION 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new BodyNode("VARIABLE-Declaración", (ASTNode)e); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_BODY_ELEMENT",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // FUNCTION_DECLARATION_BODY ::= FUNCTION_DECLARATION_BODY FUNCTION_BODY_ELEMENT 
            {
              Object RESULT =null;
		int bodyListleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyListright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object bodyList = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                ((List<BodyNode>)bodyList).add((BodyNode)body);                               
                                RESULT = bodyList; 
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_DECLARATION_BODY",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // FUNCTION_DECLARATION_BODY ::= FUNCTION_BODY_ELEMENT 
            {
              Object RESULT =null;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                                RESULT = new ArrayList<>();  
                                ((List<BodyNode>)RESULT).add((BodyNode)body) ; 
                              
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_DECLARATION_BODY",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // PARAMETER_DECLARATION_OPTION ::= PARAMETER_DECLARATION_LIST 
            {
              Object RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = params.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETER_DECLARATION_OPTION",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // PARAMETER_DECLARATION_OPTION ::= 
            {
              Object RESULT =null;
		 RESULT = ""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETER_DECLARATION_OPTION",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // PARAMETER_DECLARATION_LIST ::= PARAMETER_DECLARATION_LIST Comma PARAMETER_DECLARATION 
            {
              Object RESULT =null;
		int listleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int listright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object list = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = param.toString() + ";" + list.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETER_DECLARATION_LIST",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // PARAMETER_DECLARATION_LIST ::= PARAMETER_DECLARATION 
            {
              Object RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object param = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = param.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETER_DECLARATION_LIST",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // PARAMETER_DECLARATION ::= VARIABLE_TYPE Identifier 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = type.toString() + "@&@" + id.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETER_DECLARATION",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // FUNCTION_NAME ::= Main 
            {
              Object RESULT =null;
		 RESULT = "Main";        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_NAME",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // FUNCTION_NAME ::= Identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object id = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = id.toString(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_NAME",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // VARIABLE_TYPE ::= Char 
            {
              Object RESULT =null;
		 RESULT = "Char";    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_TYPE",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // VARIABLE_TYPE ::= Bool 
            {
              Object RESULT =null;
		 RESULT = "Bool";    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_TYPE",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // VARIABLE_TYPE ::= String 
            {
              Object RESULT =null;
		 RESULT = "String";  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_TYPE",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // VARIABLE_TYPE ::= Float 
            {
              Object RESULT =null;
		 RESULT = "Float";   
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_TYPE",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // VARIABLE_TYPE ::= Integer 
            {
              Object RESULT =null;
		 RESULT = "Integer"; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VARIABLE_TYPE",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // FUNCTION ::= VARIABLE_TYPE FUNCTION_NAME ParenthesisOpening PARAMETER_DECLARATION_OPTION ParenthesisClosure 
            {
              Object RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object type = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object name = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object params = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    currentHash = name.toString();
                    currentFunction = name.toString();

                    if(!symbolTable.containsFunctionKey(currentHash))
                    {
                        symbolTable.addFunction(name.toString(), type.toString(), params.toString());                    
                    }

                    RESULT = type.toString() + ":" + name.toString() + ":" + params.toString();
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // FUNCTION_DECLARATION ::= FUNCTION BlockOpening FUNCTION_DECLARATION_BODY BlockClosure 
            {
              Object RESULT =null;
		int fnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int fnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object fn = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int bodyleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bodyright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object body = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		                             
                            RESULT = new FunctionNode(fn.toString(), (List<BodyNode>)body);
                         
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_DECLARATION",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // FUNCTION_LIST ::= FUNCTION_LIST error 
            {
              Object RESULT =null;
		int funcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int funcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object funcs = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                          ((List<FunctionNode>)funcs).add( new FunctionNode("ERROR", new ArrayList<>() ));
                          RESULT = funcs;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_LIST",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // FUNCTION_LIST ::= error 
            {
              Object RESULT =null;
		 
                        RESULT = new ArrayList<>(); 
                        ((List<FunctionNode>) RESULT).add(new FunctionNode("ERROR", new ArrayList<>() ));
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_LIST",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // FUNCTION_LIST ::= FUNCTION_DECLARATION 
            {
              Object RESULT =null;
		int fnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object fn = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        RESULT = new ArrayList<>();
                        ((List<FunctionNode>) RESULT).add((FunctionNode)fn);
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_LIST",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // FUNCTION_LIST ::= FUNCTION_LIST FUNCTION_DECLARATION 
            {
              Object RESULT =null;
		int funcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int funcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object funcs = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object fn = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        ((List<FunctionNode>)funcs).add((FunctionNode)fn);
                        RESULT = funcs;
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCTION_LIST",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // PROGRAM ::= FUNCTION_LIST 
            {
              Object RESULT =null;
		int funcsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int funcsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object funcs = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
                RESULT = new ProgramNode();
                for (FunctionNode fn : (List<FunctionNode>)funcs) {
                    ((ProgramNode) RESULT).addFunction((FunctionNode)fn);
                }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // PROGRAM ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PROGRAM EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

